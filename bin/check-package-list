#!/usr/bin/python

# Copyright 2011 Paul Wise
# Released under the MIT/Expat license, see doc/COPYING

import os
import sys
import debian.deb822
import apt_pkg

# Setup variables
source_hash_types = {'MD5': ('Files', 32, 'md5sum'), 'SHA-1': ('Checksums-Sha1', 40, 'sha1'), 'SHA-256': ('Checksums-Sha256', 64, 'sha256')}
binary_hash_types = {'MD5': ('MD5sum', 32), 'SHA-1': ('SHA1', 40), 'SHA-256': ('SHA256', 64)}

# Init
apt_pkg.init()
output = file(os.path.abspath(sys.argv[3]), 'wb')

# Setup configuration
apt_pkg.config.set('Dir', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::Etc', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::State', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::Cache', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::State::status', os.path.abspath(os.path.join(sys.argv[2],'status')))
apt_pkg.config.set('Dir::Etc::sourcelist', os.path.abspath(sys.argv[1]))
apt_pkg.config.set('Dir::Bin::gpg', 'fakegpgv')

# Preparation
sources_list = apt_pkg.SourceList()
sources_list.read_main_list()

# Voodoo
lists_dir = apt_pkg.config.find_dir('Dir::State::lists')
binary_entries = [[i for i in x.index_files if i.label=='Debian Package Index'] for x in sources_list.list]
source_entries = [[i for i in x.index_files if i.label=='Debian Source Index'] for x in sources_list.list]

# FIXME: switch to lintian-style output with tags and descriptions
# FIXME: add some checks for the following information:
# modified dsc but unmodified parts
# unmodified dsc but modified parts (broken source package or checksums)
# less files than the Debian srcpkg
# using Release+Release.gpg instead of InRelease files
# missing hashes in Release files
# Components from Release files not listed in hashes
# Components from Release files not listed in sources.list
# missing Valid-Until/Date in Release files
# Codename is the same as Suite in Release files
# Architectures in Release files not in the list of Debian-supported ones
# No Origin/Label/Description in Release files
# Unknown fields in Release/Packages/Sources files
# Run lintian over the dsc and deb files
# Sources lists not matching Packages lists
# Empty Release/Packages/Sources files

for x in sources_list.list:
	if not x.is_trusted:
		print >>output, 'Release file not GPG signed: %s' % x.uri

for source in source_entries:
	for s in source:
		fn = os.path.join(lists_dir, s.describe.rstrip(')').rpartition('(')[2])
		try: f = file(fn)
		except:
			print >>output, 'missing Sources file %s' % fn
			continue
		for srcpkg in debian.deb822.Sources.iter_paragraphs(f):
			name = srcpkg['Package']
			version = srcpkg['Version']
			for type, (header, size, short_type) in source_hash_types.items():
				if header not in srcpkg:
					print >>output, 'source %s %s: no %s hash' % (name, version, type)
					continue
				for x in srcpkg[header]:
					if len(x[short_type]) != size:
						print >>output, 'source %s %s: %s: %s hash has unexpected size %s instead of %s' % (name, version, x['name'], type, len(x[short_type]), size)
					try: int(x[short_type], 16)
					except: print >>output, 'binary %s %s: %s hash is not a proper hexadecimal hash string (%s)' % (name, version, x['name'], type, x[short_type])
				dsc = [x for x in srcpkg[header] if x['name'].endswith('.dsc')]
				if not len(dsc):
					print >>output, 'source %s %s: %s hashes but no hash for the dsc file' % (name, version, type)
					continue
				elif len(dsc) > 1:
					print >>output, 'source %s %s: multiple dsc files and %s hashes for them' % (name, version, type)
					continue
		f.close()

for binary in binary_entries:
	for b in binary:
		fn = os.path.join(lists_dir, b.describe.rstrip(')').rpartition('(')[2])
		try: f = file(fn)
		except:
			print >>output, 'missing Packages file %s' % fn
			continue
		for binpkg in debian.deb822.Packages.iter_paragraphs(f):
			name = binpkg['Package']
			version = binpkg['Version']
			for type, (header, size) in binary_hash_types.items():
				if header not in binpkg:
					print >>output, 'binary %s %s: no %s hash' % (name, version, type)
					continue
				if len(binpkg[header]) != size:
					print >>output, 'binary %s %s: %s hash has unexpected size %s instead of %s' % (name, version, type, len(binpkg[header]), size)
				try: int(binpkg[header], 16)
				except: print >>output, 'binary %s %s: %s hash is not a proper hexadecimal hash string (%s)' % (name, version, type, binpkg[header])
		f.close()

output.close()

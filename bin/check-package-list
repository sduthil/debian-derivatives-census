#!/usr/bin/python

# Copyright 2011 Paul Wise
# Released under the MIT/Expat license, see doc/COPYING

import os
import sys
import debian.deb822
import apt_pkg
import logging

# Setup variables
source_hash_types = {'MD5': ('Files', 32, 'md5sum'), 'SHA-1': ('Checksums-Sha1', 40, 'sha1'), 'SHA-256': ('Checksums-Sha256', 64, 'sha256')}
binary_hash_types = {'MD5': ('MD5sum', 32), 'SHA-1': ('SHA1', 40), 'SHA-256': ('SHA256', 64)}

# Init
apt_pkg.init()
try: os.remove(sys.argv[3])
except: pass
logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.DEBUG, filename=sys.argv[3])

# Setup configuration
apt_pkg.config.set('Dir', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::Etc', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::State', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::Cache', os.path.abspath(sys.argv[2]))
apt_pkg.config.set('Dir::State::status', os.path.abspath(os.path.join(sys.argv[2],'status')))
apt_pkg.config.set('Dir::Etc::sourcelist', os.path.abspath(sys.argv[1]))
apt_pkg.config.set('Dir::Bin::gpg', 'fakegpgv')

# Preparation
sources_list = apt_pkg.SourceList()
sources_list.read_main_list()

# Voodoo
lists_dir = apt_pkg.config.find_dir('Dir::State::lists')
binary_entries = [[i for i in x.index_files if i.label=='Debian Package Index'] for x in sources_list.list]
source_entries = [[i for i in x.index_files if i.label=='Debian Source Index'] for x in sources_list.list]

# FIXME: switch to lintian-style output with tags and descriptions
# FIXME: add some checks for the following information:
# modified dsc but unmodified parts
# unmodified dsc but modified parts (broken source package or checksums)
# less files than the Debian srcpkg
# using Release+Release.gpg instead of InRelease files
# missing hashes in Release files
# Components from Release files not listed in hashes
# Components from Release files not listed in sources.list
# missing Valid-Until/Date in Release files
# Codename is the same as Suite in Release files
# Architectures in Release files not in the list of Debian-supported ones
# No Origin/Label/Description in Release files
# Unknown fields in Release/Packages/Sources files
# Run lintian over the dsc and deb files
# Sources lists not matching Packages lists

for x in sources_list.list:
	if not x.is_trusted:
		logging.warning('Release file not GPG signed: %s', x.uri)

for source in source_entries:
	for s in source:
		fn = os.path.join(lists_dir, s.describe.rstrip(')').rpartition('(')[2])
		try: f = file(fn)
		except:
			logging.warning('missing Sources file %s', fn)
			continue
		count = 0
		for srcpkg in debian.deb822.Sources.iter_paragraphs(f):
			count += 1
			name = srcpkg['Package']
			version = srcpkg['Version']
			for type, (header, size, short_type) in source_hash_types.items():
				if header not in srcpkg:
					logging.warning('source %s %s: no %s hash', name, version, type)
					continue
				for x in srcpkg[header]:
					if len(x[short_type]) != size:
						logging.warning('source %s %s: %s: %s hash has unexpected size %s instead of %s', name, version, x['name'], type, len(x[short_type]), size)
					try: int(x[short_type], 16)
					except: logging.warning('binary %s %s: %s hash is not a proper hexadecimal hash string (%s)', name, version, x['name'], type, x[short_type])
				dsc = [x for x in srcpkg[header] if x['name'].endswith('.dsc')]
				if not len(dsc):
					logging.warning('source %s %s: %s hashes but no hash for the dsc file', name, version, type)
					continue
				elif len(dsc) > 1:
					logging.warning('source %s %s: multiple dsc files and %s hashes for them', name, version, type)
					continue
		if count == 0:
			logging.info('empty Sources file: %s', s.describe )
		f.close()

for binary in binary_entries:
	for b in binary:
		fn = os.path.join(lists_dir, b.describe.rstrip(')').rpartition('(')[2])
		try: f = file(fn)
		except:
			logging.warning('missing Packages file %s', fn)
			continue
		count = 0
		for binpkg in debian.deb822.Packages.iter_paragraphs(f):
			count += 1
			name = binpkg['Package']
			version = binpkg['Version']
			for type, (header, size) in binary_hash_types.items():
				if header not in binpkg:
					logging.warning('binary %s %s: no %s hash', name, version, type)
					continue
				if len(binpkg[header]) != size:
					logging.warning('binary %s %s: %s hash has unexpected size %s instead of %s', name, version, type, len(binpkg[header]), size)
				try: int(binpkg[header], 16)
				except: logging.warning('binary %s %s: %s hash is not a proper hexadecimal hash string (%s)', name, version, type, binpkg[header])
		if count == 0:
			logging.info('empty Packages file: %s', b.describe )
		f.close()

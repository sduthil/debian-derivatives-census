#!/usr/bin/python

# Copyright 2011 Paul Wise
# Released under the MIT/Expat license, see doc/COPYING

# Checks the apt metadata for various issues,
# including Release, Packages and Sources files
#
# Usage:
# check-package-script <sources.list file> <apt dir> <log file>

import re
import os
import sys
import debian.deb822
import apt_pkg
import logging
import subprocess
import signal
import email.utils
import time

def remove(file):
	try: os.remove(file)
	except OSError: pass

def dump_list(file_name, list_contents):
	f = open(file_name,'wb')
	f.write(''.join('%s %s\n' % x for x in list_contents))
	f.close()

# http://www.chiark.greenend.org.uk/ucgi/~cjwatson/blosxom/2009-07-02-python-sigpipe.html
def subprocess_setup():
    # Python installs a SIGPIPE handler by default. This is usually not what
    # non-Python subprocesses expect.
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)

# Setup variables
source_hash_types = {
	'MD5': ('Files', 32, 'md5sum'),
	'SHA-1': ('Checksums-Sha1', 40, 'sha1'),
	'SHA-256': ('Checksums-Sha256', 64, 'sha256'),
	'SHA-512': ('Checksums-Sha512', 128, 'sha512'),
}
binary_hash_types = {
	'MD5': ('MD5sum', 32),
	'SHA-1': ('SHA1', 40),
	'SHA-256': ('SHA256', 64),
	'SHA-512': ('SHA512', 128),
}
release_hash_types = {
	'MD5': ('MD5Sum', 32, 'md5sum'),
	'SHA-1': ('SHA1', 40, 'sha1'),
	'SHA-256': ('SHA256', 64, 'sha256'),
	'SHA-512': ('SHA512', 128, 'sha512'),
}
release_headers = [
	'Architectures',
	'Codename',
	'Suite',
	'Components',
	'Date',
	'Valid-Until',
	'Origin',
	'Description',
	'Label',
	'Version',
	'NotAutomatic',
	'ButAutomaticUpgrades',
	'MD5Sum',
	'SHA1',
	'SHA256',
	'SHA512',
]
archs = [
	'alpha',
	'amd64',
	'arm',
	'armel',
	'armhf',
	'hppa',
	'hurd-i386',
	'i386',
	'ia64',
	'kfreebsd-amd64',
	'kfreebsd-i386',
	'mips',
	'mipsel',
	'powerpc',
	's390',
	's390x',
	'sparc',
	'avr32',
	'm68k',
	'powerpcspe',
	'sh4',
	'sparc64',
]

# Hack to add sha512 support (http://bugs.debian.org/732599)
if 'sha512' not in debian.deb822.Release._multivalued_fields:
	debian.deb822.Release._multivalued_fields['sha512'] = ['sha512', 'size', 'name']
if 'checksums-sha512' not in debian.deb822.Sources._multivalued_fields:
	debian.deb822.Sources._multivalued_fields['checksums-sha512'] = ['sha512', 'size', 'name']

# Init
apt_pkg.init()
remove(sys.argv[3])
logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.DEBUG, filename=sys.argv[3])

# Preparation
acquire = apt_pkg.Acquire()
sources_list = apt_pkg.SourceList()
sources_list.read_main_list()

# Voodoo
lists_dir = apt_pkg.config.find_dir('Dir::State::lists')
binary_entries = [[i for i in x.index_files if i.label=='Debian Package Index'] for x in sources_list.list]
source_entries = [[i for i in x.index_files if i.label=='Debian Source Index'] for x in sources_list.list]
sources_source_packages = []
sources_binary_packages = []
packages_source_packages = []
packages_binary_packages = []

# FIXME: switch to lintian-style output with tags and descriptions
# FIXME: add some checks for the following information:
# modified dsc but unmodified parts
# unmodified dsc but modified parts (broken source package or checksums)
# less files than the Debian srcpkg
# Components from Release files not listed in hashes
# Components from Release files not listed in sources.list
# missing Valid-Until/Date in Release files
# Codename is the same as Suite in Release files
# Architectures in Release files not in the list of Debian-supported ones
# No Origin/Label/Description in Release files
# Unknown fields in Release/Packages/Sources files
# Run lintian over the dsc and deb files
# Sources lists not matching Packages lists

for x in sources_list.list:
	if not x.is_trusted:
		logging.warning('Release file not GPG signed: %s', x.uri)

# Need to aquire items after checking for trust issues
sources_list.get_indexes(acquire, True)

for item in acquire.items:
	if 'Release' in item.desc_uri and 'Release.gpg' not in item.desc_uri:
		fn = item.destfile + '.reverify'
		if not os.path.exists(fn):
			fn = fn.replace('.reverify','')
		if not os.path.exists(fn):
			fn = fn.replace('/partial/','/')
		if not os.path.exists(fn):
			fn = fn.replace('InRelease','Release')
		try: f = file(fn)
		except IOError:
			logging.warning('missing Release file %s', fn)
			continue
		if 'InRelease' not in fn:
			logging.warning('not using the newer InRelease files: %s', item.desc_uri)
		release = debian.deb822.Release(f)
		for type, (header, size, short_type) in release_hash_types.items():
			if header not in release:
				if header != 'SHA512': logging.warning('release %s: no %s hash', item.desc_uri, type)
				continue
			for x in release[header]:
				if len(x[short_type]) != size:
					logging.warning('release %s: %s: %s hash has unexpected size %s instead of %s', item.desc_uri, x['name'], type, len(x[short_type]), size)
				try: int(x[short_type], 16)
				except ValueError: logging.warning('release %s: %s: %s hash is not a proper hexadecimal hash string (%s)', item.desc_uri, x['name'], type, x[short_type])
		if 'Origin' not in release:
			logging.warning('release %s: Release file missing Origin', item.desc_uri)
		elif release['Origin'] == 'Debian':
			logging.warning('release %s: Release file claims Origin is Debian', item.desc_uri)
		if 'Label' not in release:
			logging.warning('release %s: Release file missing Label', item.desc_uri)
		elif release['Label'] == 'Debian':
			logging.warning('release %s: Release file claims Label is Debian', item.desc_uri)
		if 'Date' not in release:
			logging.warning('release %s: Release file missing Date', item.desc_uri)
			date = None
		else:
			date = email.utils.parsedate_tz(release['Date'])
			if date:
				date = email.utils.mktime_tz(date)
			else:
				logging.warning('release %s: Release file Date is invalid', item.desc_uri)
		if 'Valid-Until' not in release:
			logging.warning('release %s: Release file missing Valid-Until, causing security issues', item.desc_uri)
			valid_until = None
		else:
			valid_until = email.utils.parsedate_tz(release['Valid-Until'])
			if valid_until:
				valid_until = email.utils.mktime_tz(valid_until)
			else:
				logging.warning('release %s: Release file Valid-Until is invalid', item.desc_uri)
		now = time.time()
		if date and date > now:
			logging.warning('release %s: Release file Date is after now', item.desc_uri)
		if valid_until and valid_until < now:
			logging.warning('release %s: Release file Valid-Until is before now', item.desc_uri)
		if date and valid_until and date > valid_until:
			logging.warning('release %s: Release file Date is after Valid-Until', item.desc_uri)
		if 'Architectures' not in release:
			logging.warning('release %s: Release file missing Architectures', item.desc_uri)
		if 'Suite' in release:
			if len(release['Suite'].split()) != 1:
				logging.warning('release %s: Optional header Suite does not contain single word value', item.desc_uri)
		if 'Codename' in release:
			if len(release['Codename'].split()) != 1:
				logging.warning('release %s: Optional header Codename does not contain single word value', item.desc_uri)
		if 'NotAutomatic' in release:
			if release['NotAutomatic'].lower() != 'yes' and release['NotAutomatic'].lower() != 'no':
				logging.warning('release %s: NotAutomatic header must have value of "yes" or "no"', item.desc_uri)
		if 'ButAutomaticUpgrades' in release:
			if release['ButAutomaticUpgrades'].lower() != 'yes' and release['ButAutomaticUpgrades'].lower() != 'no':
				logging.warning('release %s: ButAutomaticUpgrades header must have value of "yes" or "no"', item.desc_uri)
			if release['ButAutomaticUpgrades'].lower() == 'yes':
				if 'NotAutomatic' in release and release['NotAutomatic'].lower() != 'yes':
					logging.warning('release %s: Specifying "yes" for ButAutomaticUpgrades without specifying "yes" for NotAutomatic is invalid', item.desc_uri)
		for header, value in release.items():
			if header not in release_headers:
				logging.warning('release %s: Unknown header %s', item.desc_uri, header)
		f.close()

for source in source_entries:
	for s in source:
		fn = os.path.join(lists_dir, s.describe.rstrip(')').rpartition('(')[2])
		try: f = file(fn)
		except IOError:
			logging.warning('missing Sources file %s', fn)
			continue
		count = 0
		for srcpkg in debian.deb822.Sources.iter_paragraphs(f):
			count += 1
			name = srcpkg['Package']
			version = srcpkg['Version']
			sources_source_packages.append((name, version))
			if 'Binary' in srcpkg:
				sources_binary_packages += [(name.strip(), version) for name in srcpkg['Binary'].split(',')]
			else:
				logging.info('no binary packages for source package %s %s', name, version)
			for type, (header, size, short_type) in source_hash_types.items():
				if header not in srcpkg:
					if header != 'Checksums-Sha512': logging.warning('source %s %s: no %s hash', name, version, type)
					continue
				for x in srcpkg[header]:
					if len(x[short_type]) != size:
						logging.warning('source %s %s: %s: %s hash has unexpected size %s instead of %s', name, version, x['name'], type, len(x[short_type]), size)
					try: int(x[short_type], 16)
					except ValueError: logging.warning('source %s %s: %s hash is not a proper hexadecimal hash string (%s)', name, version, x['name'], type, x[short_type])
				dsc = [x for x in srcpkg[header] if x['name'].endswith('.dsc')]
				if not len(dsc):
					logging.warning('source %s %s: %s hashes but no hash for the dsc file', name, version, type)
					continue
				elif len(dsc) > 1:
					logging.warning('source %s %s: multiple dsc files and %s hashes for them', name, version, type)
					continue
		if count == 0:
			logging.info('empty Sources file: %s', s.describe )
		f.close()

for binary in binary_entries:
	for b in binary:
		fn = b.describe.rstrip(')').rpartition('(')[2]
		try: f = file(fn)
		except IOError:
			logging.warning('missing Packages file %s', fn)
			continue
		count = 0
		for binpkg in debian.deb822.Packages.iter_paragraphs(f):
			count += 1
			name = binpkg['Package']
			version = binpkg['Version']
			source_name = binpkg.get('Source', name)
			if ' ' in source_name:
				source_name = source_name.split(' ',1)
				source_version = source_name[1][1:-1]
				source_name = source_name[0]
			else:
				source_version = re.sub(r'\+b\d+$', '', version)
			packages_binary_packages.append((name, source_version))
			packages_source_packages.append((source_name, source_version))
			for type, (header, size) in binary_hash_types.items():
				if header not in binpkg:
					if header != 'SHA512': logging.warning('binary %s %s: no %s hash', name, version, type)
					continue
				if len(binpkg[header]) != size:
					logging.warning('binary %s %s: %s hash has unexpected size %s instead of %s', name, version, type, len(binpkg[header]), size)
				try: int(binpkg[header], 16)
				except ValueError: logging.warning('binary %s %s: %s hash is not a proper hexadecimal hash string (%s)', name, version, type, binpkg[header])
		if count == 0:
			logging.info('empty Packages file: %s', b.describe )
		f.close()

# Sort and uniqify the package name lists
sources_source_packages = list(set(sources_source_packages))
sources_binary_packages = list(set(sources_binary_packages))
packages_source_packages = list(set(packages_source_packages))
packages_binary_packages = list(set(packages_binary_packages))
sources_source_packages.sort(key=lambda pkg: (pkg[0], pkg[1]))
sources_binary_packages.sort(key=lambda pkg: (pkg[0], pkg[1]))
packages_source_packages.sort(key=lambda pkg: (pkg[0], pkg[1]))
packages_binary_packages.sort(key=lambda pkg: (pkg[0], pkg[1]))

# Check if the package name lists match
if sources_source_packages != packages_source_packages:
	logging.warning('mismatched source packages in Sources/Packages')
	dump_list('sources_source_packages', sources_source_packages)
	dump_list('packages_source_packages', packages_source_packages)
	cmdline = ['diff', '--unified', 'packages_source_packages', 'sources_source_packages']
	stdout = open('diff_source_packages', 'w')
	process = subprocess.Popen(cmdline, stdout=stdout, stderr=subprocess.PIPE, preexec_fn=subprocess_setup)
	output = process.communicate()[1]
	stdout.close()
else:
	remove('sources_source_packages')
	remove('packages_source_packages')
	remove('diff_source_packages')
if sources_binary_packages != packages_binary_packages:
	logging.warning('mismatched binary packages in Sources/Packages')
	dump_list('sources_binary_packages', sources_binary_packages)
	dump_list('packages_binary_packages', packages_binary_packages)
	cmdline = ['diff', '--unified', 'packages_binary_packages', 'sources_binary_packages']
	stdout = open('diff_binary_packages', 'w')
	process = subprocess.Popen(cmdline, stdout=stdout, stderr=subprocess.PIPE, preexec_fn=subprocess_setup)
	output = process.communicate()[1]
	stdout.close()
else:
	remove('sources_binary_packages')
	remove('packages_binary_packages')
	remove('diff_binary_packages')
